#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Copyright 2009 Red Hat, Inc. and/or its affiliates.
#
# Licensed to you under the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.  See the files README and
# LICENSE_GPL_v2 which accompany this distribution.
#

import os
import sys
import getopt
import signal
import getpass
import pwd
import grp
import threading
import logging
from logging import config as lconfig

from vdsm import constants
import zombieReaper
import dsaversion
if sys.version_info[0] == 2:
    # as long as we work with Python 2, we need to monkey-patch threading
    # module before it is ever used.
    import pthreading
    pthreading.monkey_patch()

from subprocess import Popen, PIPE, CalledProcessError
try:
    from subprocess import check_output
except ImportError:
    def func(*popenargs, **kwargs):
        if 'stdout' in kwargs:
            raise ValueError('stdout argument not allowed, it will be overridden.')
        process = Popen(stdout=PIPE, *popenargs, **kwargs)
        output, unused_err = process.communicate()
        retcode = process.poll()
        if retcode:
            cmd = kwargs.get("args")
            if cmd is None:
                cmd = popenargs[0]
            raise CalledProcessError(retcode, cmd)
        return output
    check_output = func

loggerConfFile = constants.P_VDSM_CONF + 'logger.conf'


def usage():
    print "Usage:  vdsm [OPTIONS]"
    print "     -h  - Display this help message"

# add by chenyao
def auto_start_vms(cif):
    '''自动启动已备份虚拟机，并删除失效备份'''

    from saveVmParams import SaveVmParams
    import API
    vm_params = SaveVmParams()
    vm_list = vm_params.load()
    for vmParams in vm_list:
        vm = API.VM(vmParams['vmId'])
        vm.create(vmParams)

    def get_redundance_item(src_list, dst_list):
        '''返回src_list列表中有，dst_list列表中无的元素'''

        return [it for it in src_list if it not in dst_list]

    def get_qemu_infos():
        cmd = "ps aux | grep -v grep | grep '/usr/libexec/qemu-kvm'"
        try:
            qemu_infos = check_output(cmd, shell=True).split('\n')
        except:
            qemu_infos = []
        return qemu_infos

    def get_running_vms_id():
        '''获取后台正在运行的vm id列表'''

        vms_id = []
        qemu_infos = get_qemu_infos()
        for qemu_info in qemu_infos:
            info_list = qemu_info.split(' -')[1:]
            length = len(info_list)
            for i in range(length):
                if info_list[i].startswith('uuid '):
                    uuid_info = info_list[i].split()
                    if len(uuid_info) == 2:
                        uuid = uuid_info[1]
                        vms_id.append(uuid)
                        break
        return vms_id

    def delete_not_exist_vms():
        '''删除已不存在的vmParams备份'''

        running_vms = get_running_vms_id()
        vms = cif.vmContainer.values()
        for vm in vms:
            if vm.id not in running_vms:
                vm_params.del_vmParams(vm.id)
                vm.destroy()

    threading.Timer(10.0, delete_not_exist_vms).start()

def serve_clients(log):
    cif = None

    def sigtermHandler(signum, frame):
        if cif:
            cif.prepareForShutdown()

    def sigusr1Handler(signum, frame):
        if cif and cif.irs:
            cif.irs.spmStop(
                cif.irs.getConnectedStoragePoolsList()['poollist'][0])

    # add by chenyao -- Begin
    def sigusr2Handler(signum, frame):
        if cif:
            for vm in cif.vmContainer.values():
                threading.Thread(target=shutdown_vm, args=(vm,)).start()

    def shutdown_vm(vm):
        vm.shutdown(120, 'Host will be poweroff, Virtual Machine is shutting down')
    # add by chenyao -- End

    signal.signal(signal.SIGTERM, sigtermHandler)
    signal.signal(signal.SIGUSR1, sigusr1Handler)
    signal.signal(signal.SIGUSR2, sigusr2Handler)  # add by chenyao
    zombieReaper.registerSignalHandler()

    from clientIF import clientIF  # must import after config is read
    cif = clientIF.getInstance(log)
    # add by chenyao -- Begin
    #threading.Timer(30.0, auto_start_vms, args=[cif]).start()
    #try:
    #    from sycosrpc import SycosRpc
    #    SycosRpc(cif).run_rpc()
    #    log.debug("Running sycos rpc server...")
    #except:
    #    pass
    # add by chenyao -- End
    cif.serve()


def run():
    lconfig.fileConfig(loggerConfFile)
    logging.addLevelName(5, 'TRACE')
    logging.TRACE = 5  # impolite but helpful

    # Used to debug vdsm. on production machines
    # vdsmDebugPlugin.py should not exists
    try:
        import vdsmDebugPlugin
    except ImportError:
        # This is OK, it just means the file isn't
        # there and we are not running in debug mode.
        # Any other error is an error in the debug
        # plugin and we would like to print that out.
        pass

    log = logging.getLogger('vds')
    try:
        logging.root.handlers.append(logging.StreamHandler())
        log.handlers.append(logging.StreamHandler())

        pidfile = constants.P_VDSM_RUN + 'vdsmd.pid'
        file(pidfile, 'w').write(str(os.getpid()) + "\n")
        os.chmod(pidfile, 0664)

        sysname, nodename, release, version, machine = os.uname()
        log.info('I am the actual vdsm %s-%s %s (%s)',
                 dsaversion.software_version, dsaversion.software_revision,
                 nodename, release)
        serve_clients(log)
    except:
        log.error("Exception raised", exc_info=True)

    log.info("VDSM main thread ended. Waiting for %d other threads..." %
             (threading.activeCount() - 1))
    for t in threading.enumerate():
        if hasattr(t, 'stop'):
            t.stop()
        log.info(str(t))


def parse_args():
    opts, args = getopt.getopt(sys.argv[1:], "h", ["help"])
    for o, v in opts:
        o = o.lower()
        if o == "-h" or o == "--help":
            usage()
            sys.exit(0)

    if len(args) >= 1:
        usage()
        sys.exit(1)


def __assertVdsmUser():
    username = getpass.getuser()
    assert username == constants.VDSM_USER, (
        "VDSM failed to start: running user is not %s, trying "
        "to run from user %s" % (constants.VDSM_USER, username)
    )
    group = grp.getgrnam(constants.VDSM_GROUP)
    assert (constants.VDSM_USER in group.gr_mem or
            pwd.getpwnam(constants.VDSM_USER).pw_gid == group.gr_gid), \
        "VDSM failed to start: vdsm user is not in KVM group"

if __name__ == '__main__':
    __assertVdsmUser()
    os.setpgrp()
    parse_args()
    run()
